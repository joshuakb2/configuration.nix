# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# Sometimes I need a non-tmux login shell, but changing bashrc sucks.
# Allow me to create a hidden file to prevent launching a new tmux session.
if [[ -f $HOME/.disable-tmux ]]; then
    DISABLE_TMUX=yes
fi

# If we're not in a TMUX session,
# AND we're not in a nix shell,
# AND we're not in a VS Code integrated terminal,
# AND DISABLE_TMUX is not set,
# then start a new tmux session.
if [[ ! $TMUX && $IN_NIX_SHELL != pure && ! $WORKSPACE && ! $DISABLE_TMUX ]]; then
    inheritedVars=(HYPRLAND_INSTANCE_SIGNATURE)
    tmuxArgs=(new-session)
    for arg in "${inheritedVars[@]}"; do
        tmuxArgs+=( -e "$arg=${!arg}" )
    done
    exec tmux "${tmuxArgs[@]}"
fi

if [[ $SOURCED_BASHRC == true ]]; then return 0; fi

SOURCED_BASHRC=true

tabs -4

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=100000
HISTFILESIZE=200000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

isVsCodeTerm() {
    [[ "$TERM_PROGRAM" == 'vscode' && "$WORKSPACE" && "$WORKSPACE" != '${workspaceFolder}' ]]
}
export -f isVsCodeTerm

PROMPT_COMMAND=__prompt_command

__prompt_command() {
    local exit=$?
    PS1=

    # set a fancy prompt (non-color, unless we know we "want" color)
    if [[ ! $color_prompt ]]; then
        case "$TERM" in
            xterm-color|*-256color) color_prompt=yes;;
        esac
    fi

    if (( exit != 0 )); then
        if isVsCodeTerm; then
            PS1+="\[\e[1;34m\]\$(offset=\"\$(realpath --relative-to \"\$WORKSPACE\" \"\$(pwd)\")\"; if [[ \$offset == . ]]; then echo \"\$WORKSPACE_NAME\"; elif [[ \$offset =~ ^\\.\\. ]]; then pwd; else echo \"\$WORKSPACE_NAME/\$offset\"; fi)\[\e[m\]\$ "
        elif [[ $color_prompt == yes ]]; then
            PS1+="[\\[\\033[31m\\]$exit\\[\\033[00m\\]] "
        else
            PS1+="[$exit] "
        fi
    fi

    if [ "$color_prompt" = yes ]; then
        PS1+='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
    else
        PS1+='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
    fi
}

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

alias firefox='XAUTHORITY=$HOME/.Xauthority firefox'
alias which='command -v'
alias pcat='pygmentize -g'

if [[ -f $HOME/.bash_custom ]]; then
    . $HOME/.bash_custom
fi

export CVSIGNORE='.tabs .spaces'

cvs_status() {
    cvs -q -n update -d 2>/dev/null | {
        while read -r line; do
            if [[ $line =~ ^M ]]; then
                yellow
            elif [[ $line =~ ^A ]]; then
                green
            elif [[ $line =~ ^R ]]; then
                red
            elif [[ $line =~ ^[PU] ]]; then
                blue
            fi

            echo -n "$line"
            resetColors
            echo
        done
    }
}

alias cvs_update="cvs update -d -P 2>/dev/null"

cvs_diff() {
    cvs diff -u -w "$@" 2>/dev/null | colordiff
}

cvs_reset() {
    if (( $# > 0 )); then
        rm -f -- "$@" && cvs_update "$@"
    else
        return 1
    fi
}

export EDITOR=nvim

# Redraw from the top of the screen, send bash color codes to the tty, and chop long lines rather than wrapping.
export LESS='-C -R -S -x4'

console() {
    if (( $# >= 1 )) && [[ $1 =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        stty raw
        stbssh $1 /usr/bin/get_console inout
        result=$?
        stty cooked
        return $result
    else
        env console "$@"
    fi
}

export -f console

if isVsCodeTerm; then
    WORKSPACE_NAME="$(basename "$WORKSPACE")"
    WORKSPACE_PARENT="$(basename "$(dirname "$WORKSPACE")")"

    __prompt_command() {
        local exit=$?
        PS1=

        if (( exit != 0 )); then
            PS1+="[\\[\\033[31m\\]$exit\\[\\033[00m\\]] "
        fi

        PS1+="\[\e[1;34m\]\$(offset=\"\$(realpath --relative-to \"\$WORKSPACE\" \"\$(pwd)\")\"; if [[ \$offset == . ]]; then echo \"\$WORKSPACE_NAME\"; elif [[ \$offset =~ ^\\.\\. ]]; then pwd; else echo \"\$WORKSPACE_NAME/\$offset\"; fi)\[\e[m\]\$ "
    }

    cd() {
        if (( $# == 0 )); then
            builtin cd "$WORKSPACE"
        else
            builtin cd "$@"
        fi
    }
fi

addToPath() {
  for f in "$@"; do
    export PATH="$PATH:$f"
  done
}
export -f addToPath

prependToPath() {
  local s=

  for f in "$@"; do
    s+="$f:"
  done

  PATH="$s$PATH"
}
export -f prependToPath

git-show-split() {
    git log --oneline --graph --decorate "$@" $(git merge-base "$@")^!
}
export -f git-show-split

if [[ -f $HOME/.profile ]]; then . $HOME/.profile; fi

# For host-specific bash init stuff from Nix home-manager
if [[ -f $HOME/.bashrc_host ]]; then . $HOME/.bashrc_host; fi

cgrep() {
    grep --color=always "$@"
}

red() {
    tput setaf 1
}

green() {
    tput setaf 2
}

yellow() {
    tput setaf 3
}

blue() {
    tput setaf 4
}

magenta() {
    tput setaf 5
}

cyan() {
    tput setaf 6
}

resetColors() {
    tput sgr0
}

[ -f "$HOME/.ghcup/env" ] && source "$HOME/.ghcup/env" # ghcup-env

if [[ -f "$HOME"/.paths ]]; then
    while read -r line; do
        if [[ $line =~ ^# ]]; then
            continue
        elif [[ $line =~ ^[[:space:]]*$ ]]; then
            continue
        else
            addToPath "$line"
        fi
    done < "$HOME"/.paths
fi
